name: Enhanced Hackatime Stats

on:
  workflow_dispatch:
  schedule:
    # Runs daily at 12 AM UTC (automatic)
    - cron: "0 0 * * *"

jobs:
  update-readme:
    name: Update README with Enhanced Coding Stats
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install Dependencies
        run: |
          pip install requests python-dateutil

      - name: Generate Enhanced Hackatime Stats
        env:
          HACKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
        run: |
          python << 'EOF'
          import os
          import re
          import requests
          import json
          from datetime import datetime, timezone
          from dateutil import parser

          # Configuration
          API_KEY = os.environ.get('HACKATIME_API_KEY')
          API_URL = 'https://hackatime.hackclub.com/api/hackatime/v1/users/current/stats/last_7_days'

          def fetch_hackatime_stats():
              headers = {
                  'Authorization': f'Bearer {API_KEY}',
                  'User-Agent': 'Enhanced-Hackatime-Stats/1.0'
              }

              print(f"🔍 Fetching from: {API_URL}")
              print(f"🔑 Using API key: {API_KEY[:10]}..." if API_KEY else "❌ No API key found")

              try:
                  response = requests.get(API_URL, headers=headers, timeout=30)
                  print(f"📡 Response status: {response.status_code}")

                  if response.status_code != 200:
                      print(f"❌ Error response: {response.text}")
                      return None

                  data = response.json()
                  print(f"✅ Successfully fetched data")
                  print(f"🔍 Raw API Response:")
                  print(json.dumps(data, indent=2))
                  return data
              except requests.exceptions.Timeout:
                  print("⏰ Request timed out after 30 seconds")
                  return None
              except Exception as e:
                  print(f"💥 Error fetching stats: {e}")
                  return None

          def format_duration(total_seconds):
              if total_seconds == 0:
                  return "0 mins"
              hours = total_seconds // 3600
              minutes = (total_seconds % 3600) // 60
              if hours > 0:
                  return f"{hours} hrs {minutes} mins"
              else:
                  return f"{minutes} mins"

          def create_progress_bar(percent, length=25):
              filled = int(length * percent / 100)
              empty = length - filled
              return '█' * filled + '░' * empty

          def normalize_name(name):
              """Normalize names to avoid duplicates and improve display"""
              if not name or name.strip() == "":
                  return "Other"

              name = name.strip()
              name_lower = name.lower()

              # Language normalization
              lang_map = {
                  'javascript': 'JavaScript',
                  'typescript': 'TypeScript',
                  'python': 'Python',
                  'jsx': 'JSX',
                  'tsx': 'TSX',
                  'css': 'CSS',
                  'html': 'HTML',
                  'json': 'JSON',
                  'yaml': 'YAML',
                  'yml': 'YAML',
                  'markdown': 'Markdown',
                  'md': 'Markdown',
                  'rust': 'Rust',
                  'go': 'Go',
                  'java': 'Java',
                  'c++': 'C++',
                  'cpp': 'C++',
                  'c': 'C',
                  'php': 'PHP',
                  'ruby': 'Ruby',
                  'swift': 'Swift',
                  'kotlin': 'Kotlin',
                  'dart': 'Dart',
                  'shell': 'Shell',
                  'bash': 'Bash',
                  'sql': 'SQL',
                  'dockerfile': 'Docker',
                  'docker': 'Docker'
              }

              # OS normalization
              os_map = {
                  'linux': 'Linux',
                  'windows': 'Windows',
                  'darwin': 'macOS',
                  'macos': 'macOS',
                  'ubuntu': 'Ubuntu',
                  'arch': 'Arch Linux',
                  'fedora': 'Fedora',
                  'debian': 'Debian'
              }

              # Editor normalization
              editor_map = {
                  'vscode': 'VS Code',
                  'visual studio code': 'VS Code',
                  'vim': 'Vim',
                  'neovim': 'Neovim',
                  'emacs': 'Emacs',
                  'sublime text': 'Sublime Text',
                  'atom': 'Atom',
                  'intellij': 'IntelliJ IDEA',
                  'pycharm': 'PyCharm',
                  'webstorm': 'WebStorm',
                  'android studio': 'Android Studio'
              }

              # Check all mappings
              if name_lower in lang_map:
                  return lang_map[name_lower]
              elif name_lower in os_map:
                  return os_map[name_lower]
              elif name_lower in editor_map:
                  return editor_map[name_lower]

              # Capitalize first letter for unknown items
              return name.capitalize()

          def merge_duplicates(items):
              """Merge items with the same normalized name"""
              merged = {}

              for item in items:
                  normalized_name = normalize_name(item.get('name', 'Other'))

                  if normalized_name in merged:
                      merged[normalized_name]['total_seconds'] += item.get('total_seconds', 0)
                      merged[normalized_name]['percent'] += item.get('percent', 0)
                  else:
                      item_copy = item.copy()
                      item_copy['name'] = normalized_name
                      merged[normalized_name] = item_copy

              return sorted(merged.values(), key=lambda x: x.get('total_seconds', 0), reverse=True)

          def format_section(title, items, emoji, max_items=10):
              if not items:
                  return ""

              items = merge_duplicates(items)
              content = f"\n{emoji} **{title}:**\n```text\n"

              # Show ALL items and calculate total to verify
              total_seconds_shown = 0
              for i, item in enumerate(items):
                  if i >= max_items:
                      break
                  name = item.get('name', 'Unknown')
                  time_str = format_duration(item.get('total_seconds', 0))
                  percent = item.get('percent', 0)
                  progress_bar = create_progress_bar(percent)
                  total_seconds_shown += item.get('total_seconds', 0)

                  content += f"{name:<15} {time_str:<12} {progress_bar} {percent:>6.2f}%\n"

              # Show remaining items if any
              if len(items) > max_items:
                  remaining_items = len(items) - max_items
                  remaining_seconds = sum(item.get('total_seconds', 0) for item in items[max_items:])
                  remaining_time = format_duration(remaining_seconds)
                  content += f"Other ({remaining_items}) {remaining_time:<12} ░░░░░░░░░░░░░░░░░░░░░░░░░\n"
                  total_seconds_shown += remaining_seconds

              # Debug info for time verification
              total_time_shown = format_duration(total_seconds_shown)
              content += f"Total Shown: {total_time_shown}\n"

              content += "```\n"
              return content

          def generate_enhanced_stats(data):
              print(f"🔍 Processing data structure:")
              print(f"📊 Data keys: {list(data.keys()) if data else 'None'}")

              if not data or 'data' not in data:
                  return "📊 **This Week I Spent My Time On:**\n\n```text\nNo coding activity tracked this week\n```\n"

              stats = data['data']
              print(f"📈 Stats keys: {list(stats.keys())}")
              print(f"⏱️ Total seconds: {stats.get('total_seconds', 'N/A')}")
              print(f"🕐 Human readable total: {stats.get('human_readable_total', 'N/A')}")
              print(f"💬 Languages count: {len(stats.get('languages', []))}")
              print(f"💻 OS count: {len(stats.get('operating_systems', []))}")
              print(f"🔥 Editors count: {len(stats.get('editors', []))}")
              print(f"📁 Projects count: {len(stats.get('projects', []))}")

              # Main stats content
              content = "📊 **This Week I Spent My Time On:**\n\n"

              # Total time
              total_time = stats.get('human_readable_total', 'N/A')
              if total_time != 'N/A':
                  content += f"⏱️ **Total:** {total_time}\n"

              # Programming Languages
              languages = stats.get('languages', [])
              if languages:
                  print(f"🔤 First 3 languages: {languages[:3]}")
                  print(f"🔤 Total languages in data: {len(languages)}")
                  total_lang_seconds = sum(lang.get('total_seconds', 0) for lang in languages)
                  print(f"🔤 Total seconds from all languages: {total_lang_seconds}")
                  print(f"🔤 Expected total seconds: {stats.get('total_seconds', 'N/A')}")

                  # Check if percentages add up correctly
                  total_percent = sum(lang.get('percent', 0) for lang in languages)
                  print(f"🔤 Total percentage from languages: {total_percent:.2f}%")

                  content += format_section("Programming Languages", languages, "💬", 20)

              # Operating Systems
              operating_systems = stats.get('operating_systems', [])
              if operating_systems:
                  print(f"💻 OS data: {operating_systems}")
                  os_total_seconds = sum(os.get('total_seconds', 0) for os in operating_systems)
                  print(f"💻 Total OS seconds: {os_total_seconds}")
                  content += format_section("Operating System", operating_systems, "💻", 5)

              # Editors
              editors = stats.get('editors', [])
              if editors:
                  print(f"🔥 Editors data: {editors}")
                  editors_total_seconds = sum(editor.get('total_seconds', 0) for editor in editors)
                  print(f"🔥 Total editors seconds: {editors_total_seconds}")
                  content += format_section("Editors", editors, "🔥", 5)

              # Projects
              projects = stats.get('projects', [])
              if projects:
                  print(f"📁 Projects data: {projects}")
                  projects_total_seconds = sum(project.get('total_seconds', 0) for project in projects)
                  print(f"📁 Total projects seconds: {projects_total_seconds}")
                  if len(projects) <= 15:  # Show more projects
                      content += format_section("Projects", projects, "📁", 8)
                  else:
                      print(f"📁 Too many projects ({len(projects)}), showing top 8")
                      content += format_section("Projects", projects, "📁", 8)

              # Check for other categories that might contain time
              categories = stats.get('categories', [])
              if categories:
                  print(f"📂 Categories found: {categories}")
                  cat_total_seconds = sum(cat.get('total_seconds', 0) for cat in categories)
                  print(f"📂 Total categories seconds: {cat_total_seconds}")

              machines = stats.get('machines', [])
              if machines:
                  print(f"🖥️ Machines found: {machines}")
                  machines_total_seconds = sum(machine.get('total_seconds', 0) for machine in machines)
                  print(f"🖥️ Total machines seconds: {machines_total_seconds}")

              # Final verification
              all_sections_total = total_lang_seconds + os_total_seconds + editors_total_seconds + projects_total_seconds
              expected_total = stats.get('total_seconds', 0)
              print(f"🔍 VERIFICATION:")
              print(f"   Languages: {format_duration(total_lang_seconds)}")
              print(f"   OS: {format_duration(os_total_seconds)}")
              print(f"   Editors: {format_duration(editors_total_seconds)}")
              print(f"   Projects: {format_duration(projects_total_seconds)}")
              print(f"   All sections total: {format_duration(all_sections_total)}")
              print(f"   Expected total: {format_duration(expected_total)}")
              print(f"   Difference: {format_duration(abs(expected_total - all_sections_total))}")

              # Add last updated info
              content += f"\n📅 **Last Updated:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')} UTC\n"

              return content

          def update_readme(stats_content):
              readme_path = 'README.md'

              try:
                  with open(readme_path, 'r', encoding='utf-8') as f:
                      content = f.read()
              except FileNotFoundError:
                  print("README.md not found")
                  return False

              # Pattern to match the waka section
              pattern = r'<!--START_SECTION:waka-->.*?<!--END_SECTION:waka-->'
              replacement = f'<!--START_SECTION:waka-->\n{stats_content}\n<!--END_SECTION:waka-->'

              if re.search(pattern, content, re.DOTALL):
                  new_content = re.sub(pattern, replacement, content, flags=re.DOTALL)

                  with open(readme_path, 'w', encoding='utf-8') as f:
                      f.write(new_content)

                  print("✅ README.md updated successfully")
                  return True
              else:
                  print("❌ Waka section markers not found in README.md")
                  return False

          def main():
              print("🚀 Starting enhanced Hackatime stats workflow...")

              # Check if API key exists
              if not API_KEY:
                  print("❌ HACKATIME_API_KEY environment variable not found")
                  return

              print("🔄 Fetching Hackatime stats...")
              stats_data = fetch_hackatime_stats()

              if not stats_data:
                  print("❌ Failed to fetch stats - using fallback message")
                  stats_content = "📊 **This Week I Spent My Time On:**\n\n```text\nUnable to fetch coding stats at this time\n```\n"
              else:
                  print("📊 Generating enhanced stats content...")
                  stats_content = generate_enhanced_stats(stats_data)

              print("📝 Updating README...")
              success = update_readme(stats_content)

              if success:
                  print("🎉 README updated successfully!")
              else:
                  print("💥 Failed to update README")

          if __name__ == "__main__":
              main()
          EOF

      - name: Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Enhanced Hackatime Stats"
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "📊 Updated enhanced coding stats with OS, editors, and projects"
            git push
          fi
